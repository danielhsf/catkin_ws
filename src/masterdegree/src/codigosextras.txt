1 - 
/*
        transform_2(0,0) = cos(pitch)*cos(yaw);
        transform_2(1,0) = cos(pitch)*sin(yaw);
        transform_2(2,0) = -sin(pitch);
        transform_2(0,1) = sin(roll)*sin(pitch)*cos(yaw) - cos(roll)*sin(yaw);
        transform_2(1,1) = sin(roll)*sin(pitch)*sin(yaw) + cos(roll)*cos(yaw);
        transform_2(2,1) = sin(roll)*cos(pitch);
        transform_2(0,2) = cos(roll)*sin(pitch)*cos(yaw) + sin(roll)*sin(yaw);
        transform_2(1,2) = cos(roll)*sin(pitch)*sin(yaw) - sin(roll)*cos(yaw);
        transform_2(2,2) = cos(roll)*cos(pitch);
        */
2 - 
//pcl::PointCloud<pcl::PointXYZRGBA> cloud_out;

3 - 
//Eigen::Matrix4f transform_2; 
    //float roll;
    //float pitch;
    //float yaw;
/*
        // roll (x-axis rotation)
	    float sinr_cosp = +2.0 * (orientation.w() * orientation.x() + orientation.y() * orientation.z());
	    float cosr_cosp = +1.0 - 2.0 * (orientation.x() * orientation.x() + orientation.y() * orientation.y());
	    roll = atan2f(sinr_cosp, cosr_cosp);
        //
        // pitch (y-axis rotation)
	    double sinp = +2.0 * (orientation.w() * orientation.y() - orientation.z() * orientation.x());
	    if (fabs(sinp) >= 1)
		    pitch = copysign(M_PI / 2, sinp); // use 90 degrees if out of range
	    else
		    pitch = asin(sinp);
        // yaw (z-axis rotation)
	    float siny_cosp = +2.0 * (orientation.w() * orientation.z() + orientation.x() * orientation.y());
	    float cosy_cosp = +1.0 - 2.0 * (orientation.y() * orientation.y() + orientation.z() * orientation.z());  
	    yaw = atan2f(siny_cosp, cosy_cosp);

        //roll = atan2f(2*(orientation.w()*orientation.x() + orientation.y()*orientation.z()),(1-2*(orientation.x()*orientation.x() + orientation.y()*orientation.y())));
        //pitch = asinf(2*(orientation.w()*orientation.y() - orientation.x()*orientation.z()));
        //yaw = atan2f(2*(orientation.w()*orientation.z() + orientation.x() + orientation.y()),(1-2*(orientation.y()*orientation.y() + orientation.z()*orientation.z())));
        */

4 - 
//transform_2 = Eigen::Matrix4f::Zero();
        /*
        transform_1(2,0) = -1;
        transform_1(0,1) = -1;
        transform_1(1,2) = 1;
        
        */
        transform_1(0,0) = 1;
        transform_1(2,1) = -1;
        transform_1(1,2) = 1;

        transform_1(3,3) = 1;
        transform_2(3,3) = 1;

5 - 

//IMU to World
        //printf("Roll = %f, Pitch = %f, Yaw = %f \n",roll ,pitch,yaw);
        //pcl::transformPointCloud(cloud_filtered,cloud_filtered,transform_2);